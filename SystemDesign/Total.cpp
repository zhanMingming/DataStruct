/*

https://segmentfault.com/a/1190000006025876?utm_source=tag-newest

*/

面试题1: 

1. CoreDump  bt调用栈乱序 怎么调试  gcc有参数: -fstack-protector 和 -fstack-protector-all,强烈建议开启.
 手动还原backtrace
手动记录backtrace


2. 怎么监测内存泄漏的情况，如果是内存泄漏比较缓慢，怎么办？ 特殊分支的情况

3.一千万个数，如何高效求和

4. 不用数学库，求2开平方的值，精确到小数点儿后10位


5. 进程被干掉，怎么查？
从系统日志方面查找原因。 dmesg  命令


6. CPU 高，怎么检测出来是那段程序造成的？

先按网上说的使用pstack指令打印cpu占满的进程的堆栈信息.
其中 pstack是基于gdb封装的shell脚本，有兴趣的可以去看一下。

pstack pid

发现正常的进程的堆栈显示比较正常，异常的进程的堆栈闲显示就全是？？。
这个方法行不通，就换gdb调试。

gdb -nx /proc/pid/exe pid
backtrace



7. 程序突然挂掉，core dump 没有，怎么排查问题？

https://stackoverflow.com/questions/1780765/setting-a-gdb-exit-breakpoint-not-working
 
catch syscall 60
catch syscall 231



8.单核多线程 会有线程安全的问题吗？

在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。
在单核机器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为
每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一
个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改
引起冲突。


9. Http与 Https 的区别

http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议
HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全


10. http1.1 与http2.0 的区别

HTTP/1.1    1997年   持久连接(长连接)、节约带宽、HOST域、管道机制、分块传输编码    2015年前使用最广泛
HTTP/2      2015年    多路复用、服务器推送、头信息压缩、二进制协议等                逐渐覆盖市场



11.  哪些nginx 的配置 可以调优

https://blog.csdn.net/qq_23598037/article/details/79505398

优化nginx进程个数的策略
优化绑定不同的nginx进程到不同的CPU上
nginx事件处理模型优化
调整nginx单个进程允许的客户端最大连接数
配置nginx worker进程最大打开文件数

开启高效文件传输模式 -> sendfile参数用于开启文件的高效传输模式。同时将tcp_nopush和tcp_nodelay两个指令设置为on，可防止网络及磁盘i/o阻塞，提升nginx工作效率。
配置nginx gzip压缩实现性能优化
nginx expires功能 ->  加快用户访问网站的速度, 减轻服务器压力。

限制网站来源的IP访问


12. 如何测量一个程序的CPU时间/程序的运行时间



13. 处理timewait的方法

-----------------------------

14.  异步http 客户端是怎么实现的？



15. redis 怎么动态扩容， redis 几种内存淘汰的策略

1. noeviction: 不删除策略, 达到最大内存限制时, 如果需要更多内存, 直接返回错误信息。 大多数写命令都会导致占用更多的内存(有极少数会例外, 如 DEL )。
2. allkeys-lru: 所有key通用; 优先删除最近最少使用(less recently used ,LRU) 的 key。
3. volatile-lru: 只限于设置了 expire 的部分; 优先删除最近最少使用(less recently used ,LRU) 的 key。
4. allkeys-random: 所有key通用; 随机删除一部分 key。
5. volatile-random: 只限于设置了 expire 的部分; 随机删除一部分 key。
6. volatile-ttl: 只限于设置了 expire 的部分; 优先删除剩余时间(time to live,TTL) 短的key。



# 1.设计榜单，以及自己的排名

思路：
榜单比如只需要top 1000, 维护一个 top1000 的大堆排序， 当用户积分更新的时候，如果比 排在1000名的积分要多，则将此用户替换 旧的 第1000名， 然后再重新调整顺序
自己的排名， 利用redis中的有序集合， 【 用户ID、 用户分数 】 利用分数排名



# 2. 秒杀系统 

 一个常规的秒杀系统从前到后，依次有：前端浏览器秒杀页面=》中间代理服务=》后端服务层=》数据库层

限流：屏蔽掉无用的流量，允许少部分流量流向后端。

削峰：瞬时大流量峰值容易压垮系统，解决这个问题是重中之重。常用的消峰方法有异步处理、缓存和消息中间件等技术。

异步处理：秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式。

内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。

可拓展：当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。

消息队列：消息队列可以削峰，将拦截大量并发请求，这也是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。

充分利用缓存：利用缓存可极大提高系统读写速度。 



# 3. 附近的人

1. GeoHash 算法   GeoHash将二维的经纬度转换成字符串，可以保护隐私（只表示大 概区域位置而不是具体的点），又比较容易做缓存  
字符串前缀匹配越多的距离越近  这32个字母进行base32编码

···
 首先思考一下查看附近的人的流程：

1. 用户点击查看附近的人按钮，首先获取到该用户的选位置信息（经纬度），传给服务器。
2. 服务器收到数据之后对该用户的位置信息进行geohash计算，获得该用户的位置hash字符串。
3. 对该用户的位置信息hash串进行缓存（缓存时间长短根据具体情况而定）。
4. 根据该hash串选出附近的人。
5. 对hash进行解码，计算出附近用户的位置，返回给用户

···


2. 每个用户在后台维护一个“附近的朋友”列表

3. 当用户改变半径设置时，重新计算自己的“附近的朋友”

4. 每个应用程序定期拉/长拉/。。。它自己的“附近的朋友”


# 4. Feed 流系统设计



# 5.  TB级别的文件，统计ip访问次数

分治方法：
将ip 地址转成 32 位 二进制
IP地址一般是一个32位的二进制数意思就是如果将IP地址转换成二进制表示应该有32为那么长，
但是它通常被分割为4个“8位二进制数”（也就是4个字节每，每个代表的就是小于2的8 次方）。
IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。
例：点分十进IP地址（100.4.5.6），实际上是32位二进制数（01100100.00000100.00000101.00000110）

可以按32位中低8位，将文件hash成 2^8 个文件， 保证了相同ip 会被hash 到同一个文件中。




# 6.找出文件大小为1tb的未排序数组的中值。


题目说是整数，我们认为是带符号的int,所以4字节，占32位。
假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。
从而将100亿个数字分成了两个文件，假设 file_0文件中有 60亿 个数字，file_1文件中有 40亿 个数字。那么中位数就在 file_0 文件中，

并且是 file_0 文件中所有数字排序之后的第 10亿 个数字。（file_1中的数都是负数，file_0中的数都是正数，
也即这里一共只有40亿个负数，那么排序之后的第50亿个数一定位于file_0中）

现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。

```
对于 file_0 文件，
同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），
如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。
现假设 file_0_0文件中有30亿个数字，file_0_1中也有30亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第10亿个数字。
抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有5亿个数字，
file_0_0_1中有25亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 5亿 个数。

按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。

```
对于file_0 文件, 可以根据高8位 来划分成256个小文件，比较一下每个文件的数量，就可以确定中位数 是在那个文件里面。
按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。

```

这个题目的核心思想 就是 分桶 + 快速排序。







# 7.假设你有一台拥有4个cpu核和8GB内存的机器。单任务使用90ms做IO事件，10ms做CPU计算事件，
所以总响应时间为100ms，如何设计线程池使QPS达到1000？如果单个任务使用所有100ms来执行CPU calculate事件呢？

10 *  4



# 8.设计 P2P系统

1.中心式   2.分布式      3. 多个中心结点（数据分片）


#9. 设计一个短域名的系统设计
```
一个最简单但也非常有效的方法，是建立一个这样的数据库：

Table Tiny_Url(
ID : int PRIMARY_KEY AUTO_INC,
Original_url : varchar,
Short_url : varchar
)

自增的 ID 可以被用来做转化：(ID, 10) <==> (short_url, BASE)。
每当新插入一个域名 original_url，查询语句会返回新插入的 ID，
并用它来生成短域名 short_url，保存 short_url 并返回给用户。


```



#10. 如何合理评估线程池的大小

最佳线程数目 = （(线程IO时间 + 线程CPU时间) / 线程CPU时间 ） * CPU数目




#11. 熔断 与  hystrix 熔断器
1、closed：请求正常时，不使用熔断器；, 如果请求次数异常超过设定比例，则打开熔断器。

2、open： 当熔断器打开的时候，则直接执行降级方法

3、halfopen：定期尝试发起请求来确认系统是否恢复了，如果恢复了，则熔断器将转为关闭状态。

自己实现的熔断器： 执行降级方法之后，则直接进入close 状态。





